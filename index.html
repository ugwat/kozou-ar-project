<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<title>KOZOU+ AR Experience</title>
<style>
  * { margin: 0; padding: 0; box-sizing: border-box; }
  body { width: 100%; height: 100%; background: #000; overflow: hidden; position: fixed; }
  
  /* エラー抑制用 */
  #error-suppression-container {
    display: none;
    visibility: hidden;
    position: absolute;
    width: 0;
    height: 0;
    overflow: hidden;
  }
  
  #ar-container { width: 100%; height: 100%; position: fixed; top: 0; left: 0; z-index: 1; }
  #camera-view { position: absolute; width: 100%; height: 100%; object-fit: cover; z-index: 10; background: #000; }
  .scene { position: absolute; width: 100%; height: 100%; transform-style: preserve-3d; perspective: 1400px; z-index: 20; }
  .carousel { 
    position: absolute; 
    width: 100%; 
    height: 100%; /* 全体領域使用 */
    top: 0;
    transform-style: preserve-3d; 
    /* カードを上に移動させるため、translateYを追加 */
    transform: rotateX(20deg) translateY(-100px);
  }
  .card-wrapper {
    position: absolute;
    width: 343.2px;  /* 286px × 1.2 */
    height: 589.2px; /* 491px × 1.2 */
    transform-style: preserve-3d;
    opacity: 1;
    left: 50%;
    top: 50%;
    margin-left: -171.6px; /* 幅の半分 */
    margin-top: -294.6px; /* 高さの半分 */
    will-change: transform, opacity;
    transition: transform 0.5s ease-out, opacity 0.5s ease-out;
  }
  .card {
    position: absolute;
    width: 100%;
    height: 10px; /* 最初は小さい高さ */
    bottom: 0;    /* 底から成長 */
    background-repeat: no-repeat;
    background-position: center bottom; /* 底揃え */
    background-size: cover; /* カバー設定維持 */
    border-radius: 12px;
    opacity: 0.8;
    filter: drop-shadow(0 0 10px rgba(0,255,255,0.5));
    transition: height 2.0s cubic-bezier(0.2, 0.8, 0.2, 1), opacity 2.0s, filter 0.5s;
    backface-visibility: hidden;
    will-change: height, opacity, filter;
  }
  /* 中央カードのみに適用する特別効果 */
  .card-wrapper.center .card {
    filter: drop-shadow(0 0 20px rgba(0,255,255,0.8)) drop-shadow(0 0 40px rgba(0,255,255,0.5));
  }
  /* スキャンライン効果 */
  .center .card::after {
    content: '';
    position: absolute;
    left: 0;
    height: 2px;
    width: 100%;
    background-color: rgba(0,255,255,0.5);
    animation: scanline 2s linear infinite;
    pointer-events: none;
  }
  @keyframes scanline {
    0% { top: 0; }
    100% { top: 100%; }
  }
  .overlay { 
    position: absolute; top:0; left:0; width:100%; height:100%; 
    background: radial-gradient(ellipse at center, rgba(0,0,0,0) 30%, rgba(0,0,0,0.6) 100%); 
    z-index:15; pointer-events:none;
  }
  @keyframes spin {
    0% { transform: rotate(0deg); }
    100% { transform: rotate(360deg); }
  }
  
  /* デバッグ用のカウンター表示 */
  #card-counter {
    position: fixed;
    top: 10px;
    left: 10px;
    color: white;
    background: rgba(0,0,0,0.5);
    padding: 5px 10px;
    border-radius: 5px;
    font-size: 14px;
    z-index: 1000;
  }

  /* ShowOneChildエラーの修正用スタイル追加 */
  #error-suppression-container {
    display: none;
    visibility: hidden;
    position: absolute;
    width: 0;
    height: 0;
    overflow: hidden;
  }
</style>
<script>
// ShowOneChildエラーの修正 - 先に定義して対応
window.ShowOneChild = window.ShowOneChild || {
  readRenderPromptFromStorage: function() { return null; },
  getRenderPrompt: function() { return null; },
  render: function() { return null; }
};

// localStorage拡張
if (window.localStorage && !window.localStorage.getWithTTL) {
  window.localStorage.getWithTTL = function(key) {
    return window.localStorage.getItem(key);
  };
}

// IO errorの抑制
window.addEventListener('error', function(e) {
  if (e && e.message && typeof e.message === 'string' && 
     (e.message.includes('ChromeMethodBFE') || e.message.includes('Unable to create writable file'))) {
    console.warn('IO error suppressed:', e.message);
    return true; // エラー伝播を停止
  }
}, true);

// コンソールログ追加（デバッグ用）
console.log("index.html loaded");
</script>
</head>

<body>
<!-- エラー抑制用のダミー要素 -->
<div id="error-suppression-container">
  <div id="ShowOneChild-dummy"></div>
</div>

<!-- カルーセルモード -->
<div id="ar-container">
  <video id="camera-view" autoplay playsinline muted></video>
  <div class="overlay"></div>
  <div class="scene">
    <div class="carousel"></div>
  </div>
  <div id="card-counter">カード数: 0 / 現在のインデックス: 0</div>
</div>

<script>
// グローバル変数
let activeCardIndex = 0;
let isSwipeEnabled = false;
let startX = 0;
let currentX = 0;
let isSwiping = false;
let floatAnimationFrame = null;

// カード画像の設定
const cardImages = [
  './assets/1waku.png',  // カード1枚目
  './assets/c2.png',     // カード2枚目
  './assets/c3.png',     // カード3枚目
  './assets/c4.png',     // カード4枚目
  './assets/1waku.png'   // カード5枚目
];

// 設定
const config = {
  cardSpacing: 300,           // カード間の距離
  swipeSensitivity: 200,      // スワイプの感度
  cardRotation: 30,           // カードの回転角度
  centerZ: -400,              // Z軸の奥行き
  cardCount: 5                // カードの総数
};

// ページロード時の初期化
document.addEventListener("DOMContentLoaded", function() {
  console.log("DOM loaded in index.html");
  
  // 画像の事前読み込み
  preloadImages(cardImages, function() {
    console.log("Images preloaded, creating cards");
    createCards();
  });
  
  // 画面サイズに応じた調整
  window.addEventListener('resize', function() {
    adjustForScreenSize();
    updateCardPositions();
  });
});

// 画像の事前読み込み
function preloadImages(images, callback) {
  if (!images || images.length === 0) {
    callback();
    return;
  }
  
  let loaded = 0;
  
  function imageLoaded() {
    loaded++;
    if (loaded === images.length) {
      callback();
    }
  }
  
  for (let i = 0; i < images.length; i++) {
    const img = new Image();
    img.onload = img.onerror = imageLoaded;
    img.src = images[i];
  }
}

// 画面サイズに応じたカルーセル位置の調整
function adjustForScreenSize() {
  const windowHeight = window.innerHeight;
  const carousel = document.querySelector('.carousel');
  
  if (carousel) {
    // 画面の高さに応じてtranslateYの値を調整
    if (windowHeight < 700) {
      // 小さい画面（iPhoneミニなど）
      carousel.style.transform = 'rotateX(20deg) translateY(-70px)';
    } else if (windowHeight < 900) {
      // 中サイズ画面（標準的なiPhoneなど）
      carousel.style.transform = 'rotateX(20deg) translateY(-100px)';
    } else {
      // 大きい画面（iPadなど）
      carousel.style.transform = 'rotateX(20deg) translateY(-130px)';
    }
  }
}

// カードの作成
function createCards() {
  console.log("Creating cards");
  const carousel = document.querySelector('.carousel');
  const cardCounter = document.getElementById('card-counter');
  
  // 既存のカードをクリア
  carousel.innerHTML = '';
  
  // カードの数だけループ
  for (let i = 0; i < config.cardCount; i++) {
    const wrapper = document.createElement('div');
    wrapper.className = 'card-wrapper';
    wrapper.id = `card-${i}`;
    
    const card = document.createElement('div');
    card.className = 'card';
    card.style.backgroundImage = `url(${cardImages[i]})`;
    
    wrapper.appendChild(card);
    carousel.appendChild(wrapper);
  }
  
  // カードの位置を更新
  updateCardPositions();
  
  // デバッグ情報更新
  cardCounter.textContent = `カード数: ${config.cardCount} / 現在のインデックス: ${activeCardIndex}`;
  
  // 初期状態では中央カードをフルサイズに
  setTimeout(function() {
    const centerCard = document.querySelector('.card-wrapper.center .card');
    if (centerCard) {
      centerCard.style.height = '100%';
      centerCard.style.opacity = '1';
    }
  }, 100);
  
  // イベントリスナーの設定
  setupEventListeners();
  
  // 画面サイズに合わせて調整
  adjustForScreenSize();
  
  // 浮遊アニメーションの開始
  startFloatAnimation();
  
  // 10秒後にスワイプ機能を有効化
  setTimeout(function() {
    isSwipeEnabled = true;
  }, 10000);
}

// カード位置の更新
function updateCardPositions() {
  const cards = document.querySelectorAll('.card-wrapper');
  const totalCards = cards.length;
  
  cards.forEach((card, index) => {
    // activeCardIndexからの相対位置を計算
    let relativePos = index - activeCardIndex;
    
    // 配置が循環するように調整（例：最後のカードと最初のカードが隣接）
    if (relativePos > totalCards / 2) relativePos -= totalCards;
    if (relativePos < -totalCards / 2) relativePos += totalCards;
    
    // 回転角度を計算
    const rotationY = relativePos * config.cardRotation;
    
    // Z軸の位置を計算（中央が最前面）
    const zPos = config.centerZ - Math.abs(relativePos * 100);
    
    // X軸の位置を計算（回転に応じて横に移動）
    const xPos = relativePos * config.cardSpacing;
    
    // スタイルを適用
    card.style.transform = `translateX(${xPos}px) translateZ(${zPos}px) rotateY(${rotationY}deg)`;
    
    // activeCardIndexに基づいてクラスを設定
    if (relativePos === 0) {
      card.classList.add('center');
    } else {
      card.classList.remove('center');
    }
    
    // 中央から離れるほど不透明度を下げる
    const opacity = 1 - Math.min(Math.abs(relativePos) * 0.2, 0.6);
    card.style.opacity = opacity;
  });
  
  // カード高さの更新（中央のみフルサイズ、他は小さく）
  updateCardHeights();
  
  // カウンター更新
  document.getElementById('card-counter').textContent = `カード数: ${config.cardCount} / 現在のインデックス: ${activeCardIndex}`;
}

// カードの高さを更新（中央のカードだけ大きく表示）
function updateCardHeights() {
  const cards = document.querySelectorAll('.card');
  
  cards.forEach((card, index) => {
    const wrapper = card.parentElement;
    const isCenterCard = wrapper.classList.contains('center');
    
    // 中央のカードのみアニメーションで高さを100%に
    if (isCenterCard) {
      card.style.height = '100%'; // フルサイズ
      card.style.opacity = '1';   // 完全不透明
    } else {
      card.style.height = '10px'; // 小さいサイズ（下部だけ表示）
      card.style.opacity = '0.8';  // やや透明
    }
  });
}

// 浮遊アニメーション
function startFloatAnimation() {
  if (floatAnimationFrame) {
    cancelAnimationFrame(floatAnimationFrame);
  }
  
  let time = 0;
  
  function animate() {
    time += 0.02;
    
    const centerCard = document.querySelector('.card-wrapper.center');
    if (centerCard) {
      // 軽微な浮遊感を演出
      const floatY = Math.sin(time) * 5;
      const floatX = Math.sin(time * 0.7) * 3;
      const currentTransform = centerCard.style.transform;
      
      // 既存の変換に浮遊効果を追加
      if (currentTransform.includes('translateX(')) {
        // 既存のtranslateXを正規表現で抽出
        const match = currentTransform.match(/translateX\(([^)]+)\)/);
        if (match && match[1]) {
          const baseX = parseFloat(match[1]);
          // 新しいtranslateXを元の値に浮遊効果を加えて置換
          centerCard.style.transform = currentTransform.replace(
            /translateX\([^)]+\)/, 
            `translateX(${baseX + floatX}px)`
          );
        }
      }
    }
    
    floatAnimationFrame = requestAnimationFrame(animate);
  }
  
  floatAnimationFrame = requestAnimationFrame(animate);
}

// イベントリスナーのセットアップ
function setupEventListeners() {
  const scene = document.querySelector('.scene');
  
  // タッチイベント
  scene.addEventListener('touchstart', handleTouchStart, { passive: true });
  scene.addEventListener('touchmove', handleTouchMove, { passive: false });
  scene.addEventListener('touchend', handleTouchEnd, { passive: true });
  
  // マウスイベント
  scene.addEventListener('mousedown', handleMouseDown);
  scene.addEventListener('mousemove', handleMouseMove);
  scene.addEventListener('mouseup', handleMouseUp);
  
  // リサイズイベント
  window.addEventListener('resize', function() {
    adjustForScreenSize();
    updateCardPositions();
  });
}

// タッチイベントハンドラ
function handleTouchStart(e) {
  if (!isSwipeEnabled) return;
  
  startX = e.touches[0].clientX;
  isSwiping = true;
}

function handleTouchMove(e) {
  if (!isSwiping || !isSwipeEnabled) return;
  
  currentX = e.touches[0].clientX;
  const diffX = currentX - startX;
  
  // スワイプ中の視覚的フィードバック
  if (Math.abs(diffX) > 20) {
    e.preventDefault(); // スクロール防止
    
    // カード全体を少し移動させる
    const cards = document.querySelectorAll('.card-wrapper');
    cards.forEach((card) => {
      const currentTransform = card.style.transform;
      const newTransform = currentTransform.replace(
        /translateX\([^)]+\)/, 
        `translateX(calc(${(currentTransform.match(/translateX\(([^)]+)\)/) || [,'0'])[1]} + ${diffX * 0.2}px))`
      );
      card.style.transform = newTransform;
    });
  }
}

function handleTouchEnd(e) {
  if (!isSwiping || !isSwipeEnabled) return;
  
  const endX = e.changedTouches[0].clientX;
  const diffX = endX - startX;
  
  // スワイプが一定以上の距離であれば、カードを切り替え
  if (Math.abs(diffX) > config.swipeSensitivity) {
    if (diffX > 0) {
      // 右スワイプ
      changeActiveCard(-1);
    } else {
      // 左スワイプ
      changeActiveCard(1);
    }
  } else {
    // スワイプが不十分な場合は元の位置に戻す
    updateCardPositions();
  }
  
  isSwiping = false;
}

// マウスイベントハンドラ
function handleMouseDown(e) {
  if (!isSwipeEnabled) return;
  
  startX = e.clientX;
  isSwiping = true;
  e.preventDefault();
}

function handleMouseMove(e) {
  if (!isSwiping || !isSwipeEnabled) return;
  
  currentX = e.clientX;
  const diffX = currentX - startX;
  
  // スワイプ中の視覚的フィードバック
  if (Math.abs(diffX) > 20) {
    // カード全体を少し移動させる
    const cards = document.querySelectorAll('.card-wrapper');
    cards.forEach((card) => {
      const currentTransform = card.style.transform;
      const newTransform = currentTransform.replace(
        /translateX\([^)]+\)/, 
        `translateX(calc(${(currentTransform.match(/translateX\(([^)]+)\)/) || [,'0'])[1]} + ${diffX * 0.2}px))`
      );
      card.style.transform = newTransform;
    });
  }
}

function handleMouseUp(e) {
  if (!isSwiping || !isSwipeEnabled) return;
  
  const endX = e.clientX;
  const diffX = endX - startX;
  
  // スワイプが一定以上の距離であれば、カードを切り替え
  if (Math.abs(diffX) > config.swipeSensitivity) {
    if (diffX > 0) {
      // 右スワイプ
      changeActiveCard(-1);
    } else {
      // 左スワイプ
      changeActiveCard(1);
    }
  } else {
    // スワイプが不十分な場合は元の位置に戻す
    updateCardPositions();
  }
  
  isSwiping = false;
}

// アクティブカードの変更
function changeActiveCard(direction) {
  // アクティブカードインデックスを更新
  activeCardIndex = (activeCardIndex + direction + config.cardCount) % config.cardCount;
  
  // カード位置を更新
  updateCardPositions();
}

// モバイル環境でのカメラアクセス
// scan.htmlで既にカメラアクセスを要求しているので、直接アクセスする必要はありません
// このコメントを残しておくことで、他の開発者が理解しやすくなります
</script>
</body>
</html>